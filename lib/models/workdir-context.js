"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _eventKit = require("event-kit");
var _repository = _interopRequireDefault(require("./repository"));
var _resolutionProgress = _interopRequireDefault(require("./conflicts/resolution-progress"));
var _fileSystemChangeObserver = _interopRequireDefault(require("./file-system-change-observer"));
var _workspaceChangeObserver = _interopRequireDefault(require("./workspace-change-observer"));
var _helpers = require("../helpers");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const createRepoSym = Symbol('createRepo');
let absentWorkdirContext;

/*
 * Bundle of model objects associated with a git working directory.
 *
 * Provides synchronous access to each model in the form of a getter method that returns the model or `null` if it
 * has not yet been initialized, and asynchronous access in the form of a Promise generation method that will resolve
 * once the model is available. Initializes the platform-appropriate change observer and proxies select filesystem
 * change events.
 */
class WorkdirContext {
  /*
   * Available options:
   * - `options.window`: Browser window global, used on Linux by the WorkspaceChangeObserver.
   * - `options.workspace`: Atom's workspace singleton, used on Linux by the WorkspaceChangeObserver.
   * - `options.promptCallback`: Callback used to collect information interactively through Atom.
   */
  constructor(directory, options = {}) {
    (0, _helpers.autobind)(this, 'repositoryChangedState');
    this.directory = directory;
    const {
      window: theWindow,
      workspace,
      promptCallback,
      pipelineManager
    } = options;
    this.repository = (options[createRepoSym] || (() => new _repository.default(directory, null, {
      pipelineManager
    })))();
    this.destroyed = false;
    this.emitter = new _eventKit.Emitter();
    this.subs = new _eventKit.CompositeDisposable();
    this.observer = this.useWorkspaceChangeObserver() ? new _workspaceChangeObserver.default(theWindow, workspace, this.repository) : new _fileSystemChangeObserver.default(this.repository);
    this.resolutionProgress = new _resolutionProgress.default();
    if (promptCallback) {
      this.repository.setPromptCallback(promptCallback);
    }

    // Wire up event forwarding among models
    this.subs.add(this.repository.onDidChangeState(this.repositoryChangedState));
    this.subs.add(this.observer.onDidChange(events => {
      this.repository.observeFilesystemChange(events);
    }));
    this.subs.add(this.observer.onDidChangeWorkdirOrHead(() => this.emitter.emit('did-change-workdir-or-head')));

    // If a pre-loaded Repository was provided, broadcast an initial state change event.
    this.repositoryChangedState({
      from: null,
      to: this.repository.state
    });
  }
  static absent(options) {
    if (!absentWorkdirContext) {
      absentWorkdirContext = new AbsentWorkdirContext(options);
    }
    return absentWorkdirContext;
  }
  static destroyAbsent() {
    if (absentWorkdirContext) {
      absentWorkdirContext.destroy();
      absentWorkdirContext = null;
    }
  }
  static guess(options, pipelineManager) {
    const projectPathCount = options.projectPathCount || 0;
    const initPathCount = options.initPathCount || 0;
    const createRepo = projectPathCount === 1 || projectPathCount === 0 && initPathCount === 1 ? () => _repository.default.loadingGuess({
      pipelineManager
    }) : () => _repository.default.absentGuess({
      pipelineManager
    });
    return new WorkdirContext(null, {
      [createRepoSym]: createRepo
    });
  }

  /**
   * Respond to changes in `Repository` state. Load resolution progress and start the change observer when it becomes
   * present. Stop the change observer when it is destroyed. Re-broadcast the event to context subscribers
   * regardless.
   *
   * The ResolutionProgress will be loaded before the change event is re-broadcast, but change observer modifications
   * will not be complete.
   */
  repositoryChangedState(payload) {
    if (this.destroyed) {
      return;
    }
    if (this.repository.isPresent()) {
      this.observer.start().then(() => this.emitter.emit('did-start-observer'));
    } else if (this.repository.isDestroyed()) {
      this.emitter.emit('did-destroy-repository');
      this.observer.destroy();
    }
    this.emitter.emit('did-change-repository-state', payload);
  }
  isPresent() {
    return true;
  }
  isDestroyed() {
    return this.destroyed;
  }
  useWorkspaceChangeObserver() {
    return !!process.env.ATOM_GITHUB_WORKSPACE_OBSERVER || process.platform === 'linux';
  }

  // Event subscriptions

  onDidStartObserver(callback) {
    return this.emitter.on('did-start-observer', callback);
  }
  onDidChangeWorkdirOrHead(callback) {
    return this.emitter.on('did-change-workdir-or-head', callback);
  }
  onDidChangeRepositoryState(callback) {
    return this.emitter.on('did-change-repository-state', callback);
  }
  onDidUpdateRepository(callback) {
    return this.emitter.on('did-update-repository', callback);
  }
  onDidDestroyRepository(callback) {
    return this.emitter.on('did-destroy-repository', callback);
  }

  /**
   * Return a Promise that will resolve the next time that a Repository transitions to the requested state. Most
   * useful for test cases; most callers should prefer subscribing to `onDidChangeRepositoryState`.
   */
  getRepositoryStatePromise(stateName) {
    return new Promise(resolve => {
      const sub = this.onDidChangeRepositoryState(() => {
        if (this.repository.isInState(stateName)) {
          resolve();
          sub.dispose();
        }
      });
    });
  }

  /**
   * Return a Promise that will resolve the next time that a ChangeObserver successfully starts. Most useful for
   * test cases.
   */
  getObserverStartedPromise() {
    return new Promise(resolve => {
      const sub = this.onDidStartObserver(() => {
        resolve();
        sub.dispose();
      });
    });
  }
  getWorkingDirectory() {
    return this.directory;
  }
  getRepository() {
    return this.repository;
  }
  getChangeObserver() {
    return this.observer;
  }
  getResolutionProgress() {
    return this.resolutionProgress;
  }

  /*
   * Cleanly destroy any models that need to be cleaned, including stopping the filesystem watcher.
   */
  async destroy() {
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    this.subs.dispose();
    this.repository.destroy();
    this.emitter.dispose();
    await this.observer.destroy();
  }
}
exports.default = WorkdirContext;
class AbsentWorkdirContext extends WorkdirContext {
  constructor(options) {
    super(null, {
      [createRepoSym]: () => _repository.default.absent(options)
    });
  }
  isPresent() {
    return false;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVSZXBvU3ltIiwiU3ltYm9sIiwiYWJzZW50V29ya2RpckNvbnRleHQiLCJXb3JrZGlyQ29udGV4dCIsImNvbnN0cnVjdG9yIiwiZGlyZWN0b3J5Iiwib3B0aW9ucyIsImF1dG9iaW5kIiwid2luZG93IiwidGhlV2luZG93Iiwid29ya3NwYWNlIiwicHJvbXB0Q2FsbGJhY2siLCJwaXBlbGluZU1hbmFnZXIiLCJyZXBvc2l0b3J5IiwiUmVwb3NpdG9yeSIsImRlc3Ryb3llZCIsImVtaXR0ZXIiLCJFbWl0dGVyIiwic3VicyIsIkNvbXBvc2l0ZURpc3Bvc2FibGUiLCJvYnNlcnZlciIsInVzZVdvcmtzcGFjZUNoYW5nZU9ic2VydmVyIiwiV29ya3NwYWNlQ2hhbmdlT2JzZXJ2ZXIiLCJGaWxlU3lzdGVtQ2hhbmdlT2JzZXJ2ZXIiLCJyZXNvbHV0aW9uUHJvZ3Jlc3MiLCJSZXNvbHV0aW9uUHJvZ3Jlc3MiLCJzZXRQcm9tcHRDYWxsYmFjayIsImFkZCIsIm9uRGlkQ2hhbmdlU3RhdGUiLCJyZXBvc2l0b3J5Q2hhbmdlZFN0YXRlIiwib25EaWRDaGFuZ2UiLCJldmVudHMiLCJvYnNlcnZlRmlsZXN5c3RlbUNoYW5nZSIsIm9uRGlkQ2hhbmdlV29ya2Rpck9ySGVhZCIsImVtaXQiLCJmcm9tIiwidG8iLCJzdGF0ZSIsImFic2VudCIsIkFic2VudFdvcmtkaXJDb250ZXh0IiwiZGVzdHJveUFic2VudCIsImRlc3Ryb3kiLCJndWVzcyIsInByb2plY3RQYXRoQ291bnQiLCJpbml0UGF0aENvdW50IiwiY3JlYXRlUmVwbyIsImxvYWRpbmdHdWVzcyIsImFic2VudEd1ZXNzIiwicGF5bG9hZCIsImlzUHJlc2VudCIsInN0YXJ0IiwidGhlbiIsImlzRGVzdHJveWVkIiwicHJvY2VzcyIsImVudiIsIkFUT01fR0lUSFVCX1dPUktTUEFDRV9PQlNFUlZFUiIsInBsYXRmb3JtIiwib25EaWRTdGFydE9ic2VydmVyIiwiY2FsbGJhY2siLCJvbiIsIm9uRGlkQ2hhbmdlUmVwb3NpdG9yeVN0YXRlIiwib25EaWRVcGRhdGVSZXBvc2l0b3J5Iiwib25EaWREZXN0cm95UmVwb3NpdG9yeSIsImdldFJlcG9zaXRvcnlTdGF0ZVByb21pc2UiLCJzdGF0ZU5hbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN1YiIsImlzSW5TdGF0ZSIsImRpc3Bvc2UiLCJnZXRPYnNlcnZlclN0YXJ0ZWRQcm9taXNlIiwiZ2V0V29ya2luZ0RpcmVjdG9yeSIsImdldFJlcG9zaXRvcnkiLCJnZXRDaGFuZ2VPYnNlcnZlciIsImdldFJlc29sdXRpb25Qcm9ncmVzcyJdLCJzb3VyY2VzIjpbIndvcmtkaXItY29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VtaXR0ZXIsIENvbXBvc2l0ZURpc3Bvc2FibGV9IGZyb20gJ2V2ZW50LWtpdCc7XG5cbmltcG9ydCBSZXBvc2l0b3J5IGZyb20gJy4vcmVwb3NpdG9yeSc7XG5pbXBvcnQgUmVzb2x1dGlvblByb2dyZXNzIGZyb20gJy4vY29uZmxpY3RzL3Jlc29sdXRpb24tcHJvZ3Jlc3MnO1xuaW1wb3J0IEZpbGVTeXN0ZW1DaGFuZ2VPYnNlcnZlciBmcm9tICcuL2ZpbGUtc3lzdGVtLWNoYW5nZS1vYnNlcnZlcic7XG5pbXBvcnQgV29ya3NwYWNlQ2hhbmdlT2JzZXJ2ZXIgZnJvbSAnLi93b3Jrc3BhY2UtY2hhbmdlLW9ic2VydmVyJztcbmltcG9ydCB7YXV0b2JpbmR9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG5jb25zdCBjcmVhdGVSZXBvU3ltID0gU3ltYm9sKCdjcmVhdGVSZXBvJyk7XG5cbmxldCBhYnNlbnRXb3JrZGlyQ29udGV4dDtcblxuLypcbiAqIEJ1bmRsZSBvZiBtb2RlbCBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdCB3b3JraW5nIGRpcmVjdG9yeS5cbiAqXG4gKiBQcm92aWRlcyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gZWFjaCBtb2RlbCBpbiB0aGUgZm9ybSBvZiBhIGdldHRlciBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBtb2RlbCBvciBgbnVsbGAgaWYgaXRcbiAqIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQsIGFuZCBhc3luY2hyb25vdXMgYWNjZXNzIGluIHRoZSBmb3JtIG9mIGEgUHJvbWlzZSBnZW5lcmF0aW9uIG1ldGhvZCB0aGF0IHdpbGwgcmVzb2x2ZVxuICogb25jZSB0aGUgbW9kZWwgaXMgYXZhaWxhYmxlLiBJbml0aWFsaXplcyB0aGUgcGxhdGZvcm0tYXBwcm9wcmlhdGUgY2hhbmdlIG9ic2VydmVyIGFuZCBwcm94aWVzIHNlbGVjdCBmaWxlc3lzdGVtXG4gKiBjaGFuZ2UgZXZlbnRzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZGlyQ29udGV4dCB7XG5cbiAgLypcbiAgICogQXZhaWxhYmxlIG9wdGlvbnM6XG4gICAqIC0gYG9wdGlvbnMud2luZG93YDogQnJvd3NlciB3aW5kb3cgZ2xvYmFsLCB1c2VkIG9uIExpbnV4IGJ5IHRoZSBXb3Jrc3BhY2VDaGFuZ2VPYnNlcnZlci5cbiAgICogLSBgb3B0aW9ucy53b3Jrc3BhY2VgOiBBdG9tJ3Mgd29ya3NwYWNlIHNpbmdsZXRvbiwgdXNlZCBvbiBMaW51eCBieSB0aGUgV29ya3NwYWNlQ2hhbmdlT2JzZXJ2ZXIuXG4gICAqIC0gYG9wdGlvbnMucHJvbXB0Q2FsbGJhY2tgOiBDYWxsYmFjayB1c2VkIHRvIGNvbGxlY3QgaW5mb3JtYXRpb24gaW50ZXJhY3RpdmVseSB0aHJvdWdoIEF0b20uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkaXJlY3RvcnksIG9wdGlvbnMgPSB7fSkge1xuICAgIGF1dG9iaW5kKHRoaXMsICdyZXBvc2l0b3J5Q2hhbmdlZFN0YXRlJyk7XG5cbiAgICB0aGlzLmRpcmVjdG9yeSA9IGRpcmVjdG9yeTtcblxuICAgIGNvbnN0IHt3aW5kb3c6IHRoZVdpbmRvdywgd29ya3NwYWNlLCBwcm9tcHRDYWxsYmFjaywgcGlwZWxpbmVNYW5hZ2VyfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5yZXBvc2l0b3J5ID0gKG9wdGlvbnNbY3JlYXRlUmVwb1N5bV0gfHwgKCgpID0+IG5ldyBSZXBvc2l0b3J5KGRpcmVjdG9yeSwgbnVsbCwge3BpcGVsaW5lTWFuYWdlcn0pKSkoKTtcblxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB0aGlzLnN1YnMgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuXG4gICAgdGhpcy5vYnNlcnZlciA9IHRoaXMudXNlV29ya3NwYWNlQ2hhbmdlT2JzZXJ2ZXIoKVxuICAgICAgPyBuZXcgV29ya3NwYWNlQ2hhbmdlT2JzZXJ2ZXIodGhlV2luZG93LCB3b3Jrc3BhY2UsIHRoaXMucmVwb3NpdG9yeSlcbiAgICAgIDogbmV3IEZpbGVTeXN0ZW1DaGFuZ2VPYnNlcnZlcih0aGlzLnJlcG9zaXRvcnkpO1xuICAgIHRoaXMucmVzb2x1dGlvblByb2dyZXNzID0gbmV3IFJlc29sdXRpb25Qcm9ncmVzcygpO1xuXG4gICAgaWYgKHByb21wdENhbGxiYWNrKSB7XG4gICAgICB0aGlzLnJlcG9zaXRvcnkuc2V0UHJvbXB0Q2FsbGJhY2socHJvbXB0Q2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIFdpcmUgdXAgZXZlbnQgZm9yd2FyZGluZyBhbW9uZyBtb2RlbHNcbiAgICB0aGlzLnN1YnMuYWRkKHRoaXMucmVwb3NpdG9yeS5vbkRpZENoYW5nZVN0YXRlKHRoaXMucmVwb3NpdG9yeUNoYW5nZWRTdGF0ZSkpO1xuICAgIHRoaXMuc3Vicy5hZGQodGhpcy5vYnNlcnZlci5vbkRpZENoYW5nZShldmVudHMgPT4ge1xuICAgICAgdGhpcy5yZXBvc2l0b3J5Lm9ic2VydmVGaWxlc3lzdGVtQ2hhbmdlKGV2ZW50cyk7XG4gICAgfSkpO1xuICAgIHRoaXMuc3Vicy5hZGQodGhpcy5vYnNlcnZlci5vbkRpZENoYW5nZVdvcmtkaXJPckhlYWQoKCkgPT4gdGhpcy5lbWl0dGVyLmVtaXQoJ2RpZC1jaGFuZ2Utd29ya2Rpci1vci1oZWFkJykpKTtcblxuICAgIC8vIElmIGEgcHJlLWxvYWRlZCBSZXBvc2l0b3J5IHdhcyBwcm92aWRlZCwgYnJvYWRjYXN0IGFuIGluaXRpYWwgc3RhdGUgY2hhbmdlIGV2ZW50LlxuICAgIHRoaXMucmVwb3NpdG9yeUNoYW5nZWRTdGF0ZSh7ZnJvbTogbnVsbCwgdG86IHRoaXMucmVwb3NpdG9yeS5zdGF0ZX0pO1xuICB9XG5cbiAgc3RhdGljIGFic2VudChvcHRpb25zKSB7XG4gICAgaWYgKCFhYnNlbnRXb3JrZGlyQ29udGV4dCkge1xuICAgICAgYWJzZW50V29ya2RpckNvbnRleHQgPSBuZXcgQWJzZW50V29ya2RpckNvbnRleHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhYnNlbnRXb3JrZGlyQ29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95QWJzZW50KCkge1xuICAgIGlmIChhYnNlbnRXb3JrZGlyQ29udGV4dCkge1xuICAgICAgYWJzZW50V29ya2RpckNvbnRleHQuZGVzdHJveSgpO1xuICAgICAgYWJzZW50V29ya2RpckNvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBndWVzcyhvcHRpb25zLCBwaXBlbGluZU1hbmFnZXIpIHtcbiAgICBjb25zdCBwcm9qZWN0UGF0aENvdW50ID0gb3B0aW9ucy5wcm9qZWN0UGF0aENvdW50IHx8IDA7XG4gICAgY29uc3QgaW5pdFBhdGhDb3VudCA9IG9wdGlvbnMuaW5pdFBhdGhDb3VudCB8fCAwO1xuXG4gICAgY29uc3QgY3JlYXRlUmVwbyA9IChwcm9qZWN0UGF0aENvdW50ID09PSAxIHx8IChwcm9qZWN0UGF0aENvdW50ID09PSAwICYmIGluaXRQYXRoQ291bnQgPT09IDEpKSA/XG4gICAgICAoKSA9PiBSZXBvc2l0b3J5LmxvYWRpbmdHdWVzcyh7cGlwZWxpbmVNYW5hZ2VyfSkgOlxuICAgICAgKCkgPT4gUmVwb3NpdG9yeS5hYnNlbnRHdWVzcyh7cGlwZWxpbmVNYW5hZ2VyfSk7XG5cbiAgICByZXR1cm4gbmV3IFdvcmtkaXJDb250ZXh0KG51bGwsIHtbY3JlYXRlUmVwb1N5bV06IGNyZWF0ZVJlcG99KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNwb25kIHRvIGNoYW5nZXMgaW4gYFJlcG9zaXRvcnlgIHN0YXRlLiBMb2FkIHJlc29sdXRpb24gcHJvZ3Jlc3MgYW5kIHN0YXJ0IHRoZSBjaGFuZ2Ugb2JzZXJ2ZXIgd2hlbiBpdCBiZWNvbWVzXG4gICAqIHByZXNlbnQuIFN0b3AgdGhlIGNoYW5nZSBvYnNlcnZlciB3aGVuIGl0IGlzIGRlc3Ryb3llZC4gUmUtYnJvYWRjYXN0IHRoZSBldmVudCB0byBjb250ZXh0IHN1YnNjcmliZXJzXG4gICAqIHJlZ2FyZGxlc3MuXG4gICAqXG4gICAqIFRoZSBSZXNvbHV0aW9uUHJvZ3Jlc3Mgd2lsbCBiZSBsb2FkZWQgYmVmb3JlIHRoZSBjaGFuZ2UgZXZlbnQgaXMgcmUtYnJvYWRjYXN0LCBidXQgY2hhbmdlIG9ic2VydmVyIG1vZGlmaWNhdGlvbnNcbiAgICogd2lsbCBub3QgYmUgY29tcGxldGUuXG4gICAqL1xuICByZXBvc2l0b3J5Q2hhbmdlZFN0YXRlKHBheWxvYWQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXBvc2l0b3J5LmlzUHJlc2VudCgpKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLnN0YXJ0KCkudGhlbigoKSA9PiB0aGlzLmVtaXR0ZXIuZW1pdCgnZGlkLXN0YXJ0LW9ic2VydmVyJykpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZXBvc2l0b3J5LmlzRGVzdHJveWVkKCkpIHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KCdkaWQtZGVzdHJveS1yZXBvc2l0b3J5Jyk7XG5cbiAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdHRlci5lbWl0KCdkaWQtY2hhbmdlLXJlcG9zaXRvcnktc3RhdGUnLCBwYXlsb2FkKTtcbiAgfVxuXG4gIGlzUHJlc2VudCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzRGVzdHJveWVkKCkge1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3llZDtcbiAgfVxuXG4gIHVzZVdvcmtzcGFjZUNoYW5nZU9ic2VydmVyKCkge1xuICAgIHJldHVybiAhIXByb2Nlc3MuZW52LkFUT01fR0lUSFVCX1dPUktTUEFDRV9PQlNFUlZFUiB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnO1xuICB9XG5cbiAgLy8gRXZlbnQgc3Vic2NyaXB0aW9uc1xuXG4gIG9uRGlkU3RhcnRPYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oJ2RpZC1zdGFydC1vYnNlcnZlcicsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIG9uRGlkQ2hhbmdlV29ya2Rpck9ySGVhZChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oJ2RpZC1jaGFuZ2Utd29ya2Rpci1vci1oZWFkJywgY2FsbGJhY2spO1xuICB9XG5cbiAgb25EaWRDaGFuZ2VSZXBvc2l0b3J5U3RhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uKCdkaWQtY2hhbmdlLXJlcG9zaXRvcnktc3RhdGUnLCBjYWxsYmFjayk7XG4gIH1cblxuICBvbkRpZFVwZGF0ZVJlcG9zaXRvcnkoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uKCdkaWQtdXBkYXRlLXJlcG9zaXRvcnknLCBjYWxsYmFjayk7XG4gIH1cblxuICBvbkRpZERlc3Ryb3lSZXBvc2l0b3J5KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vbignZGlkLWRlc3Ryb3ktcmVwb3NpdG9yeScsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRoZSBuZXh0IHRpbWUgdGhhdCBhIFJlcG9zaXRvcnkgdHJhbnNpdGlvbnMgdG8gdGhlIHJlcXVlc3RlZCBzdGF0ZS4gTW9zdFxuICAgKiB1c2VmdWwgZm9yIHRlc3QgY2FzZXM7IG1vc3QgY2FsbGVycyBzaG91bGQgcHJlZmVyIHN1YnNjcmliaW5nIHRvIGBvbkRpZENoYW5nZVJlcG9zaXRvcnlTdGF0ZWAuXG4gICAqL1xuICBnZXRSZXBvc2l0b3J5U3RhdGVQcm9taXNlKHN0YXRlTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHN1YiA9IHRoaXMub25EaWRDaGFuZ2VSZXBvc2l0b3J5U3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5yZXBvc2l0b3J5LmlzSW5TdGF0ZShzdGF0ZU5hbWUpKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHN1Yi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdGhlIG5leHQgdGltZSB0aGF0IGEgQ2hhbmdlT2JzZXJ2ZXIgc3VjY2Vzc2Z1bGx5IHN0YXJ0cy4gTW9zdCB1c2VmdWwgZm9yXG4gICAqIHRlc3QgY2FzZXMuXG4gICAqL1xuICBnZXRPYnNlcnZlclN0YXJ0ZWRQcm9taXNlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHN1YiA9IHRoaXMub25EaWRTdGFydE9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICBzdWIuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRXb3JraW5nRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLmRpcmVjdG9yeTtcbiAgfVxuXG4gIGdldFJlcG9zaXRvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3NpdG9yeTtcbiAgfVxuXG4gIGdldENoYW5nZU9ic2VydmVyKCkge1xuICAgIHJldHVybiB0aGlzLm9ic2VydmVyO1xuICB9XG5cbiAgZ2V0UmVzb2x1dGlvblByb2dyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25Qcm9ncmVzcztcbiAgfVxuXG4gIC8qXG4gICAqIENsZWFubHkgZGVzdHJveSBhbnkgbW9kZWxzIHRoYXQgbmVlZCB0byBiZSBjbGVhbmVkLCBpbmNsdWRpbmcgc3RvcHBpbmcgdGhlIGZpbGVzeXN0ZW0gd2F0Y2hlci5cbiAgICovXG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIHRoaXMuc3Vicy5kaXNwb3NlKCk7XG4gICAgdGhpcy5yZXBvc2l0b3J5LmRlc3Ryb3koKTtcbiAgICB0aGlzLmVtaXR0ZXIuZGlzcG9zZSgpO1xuXG4gICAgYXdhaXQgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuY2xhc3MgQWJzZW50V29ya2RpckNvbnRleHQgZXh0ZW5kcyBXb3JrZGlyQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihudWxsLCB7W2NyZWF0ZVJlcG9TeW1dOiAoKSA9PiBSZXBvc2l0b3J5LmFic2VudChvcHRpb25zKX0pO1xuICB9XG5cbiAgaXNQcmVzZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBb0M7QUFFcEMsTUFBTUEsYUFBYSxHQUFHQyxNQUFNLENBQUMsWUFBWSxDQUFDO0FBRTFDLElBQUlDLG9CQUFvQjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU1DLGNBQWMsQ0FBQztFQUVsQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDRUMsV0FBVyxDQUFDQyxTQUFTLEVBQUVDLE9B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